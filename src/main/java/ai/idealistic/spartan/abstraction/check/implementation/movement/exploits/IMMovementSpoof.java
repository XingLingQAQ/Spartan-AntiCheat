package ai.idealistic.spartan.abstraction.check.implementation.movement.exploits;

import ai.idealistic.spartan.abstraction.check.Check;
import ai.idealistic.spartan.abstraction.check.CheckDetection;
import ai.idealistic.spartan.abstraction.check.CheckRunner;
import ai.idealistic.spartan.abstraction.world.ServerLocation;
import ai.idealistic.spartan.functionality.server.MultiVersion;
import ai.idealistic.spartan.functionality.server.TPS;
import ai.idealistic.spartan.utils.math.AlgebraUtils;
import ai.idealistic.spartan.utils.minecraft.entity.PlayerUtils;

import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

public class IMMovementSpoof extends CheckDetection {

    private static final boolean v1_9 = MultiVersion.isOrGreater(MultiVersion.MCVersion.V1_9);
    private static final long outdatedDelayTime = AlgebraUtils.integerCeil(TPS.maximum) * 1_000L;
    private static final double outdatedTickTime = TPS.tickTime * 1.1;

    private double oldSpoofDistance;
    private long lastEvent, lastSpoof, spoofIncreaseLimit;
    private int delayBuffer, delayTimes;
    private final List<Long> average;

    IMMovementSpoof(CheckRunner executor) {
        super(executor, null, Check.DetectionType.BUKKIT, "movement_spoof", true);
        this.average = Collections.synchronizedList(new LinkedList<>());
        this.delayBuffer = 0;
        this.delayTimes = 0;

        if (v1_9) {
            this.lastEvent = Long.MAX_VALUE;
        }
    }

    void run() {
        this.call(() -> {
            if (v1_9) {
                long time = System.currentTimeMillis();
                double distance = ServerLocation.distance(
                        this.protocol.getLocation(),
                        this.protocol.getSchedulerFrom()
                );

                if (distance > (this.protocol.getVehicle() == null
                        || this.spoofIncreaseLimit >= System.currentTimeMillis()
                        ? PlayerUtils.optimizationY
                        : 0.1)) {
                    long timePassed = time - lastEvent;

                    if (timePassed >= 1_000L) {
                        timePassed = time - lastSpoof;
                        this.lastSpoof = time;
                        this.updateInternal(time);

                        if (timePassed <= 1_000L
                                && oldSpoofDistance != distance) {
                            oldSpoofDistance = distance;
                            cancel(
                                    "movement-spoof(default)"
                                            + ", distance: " + distance,
                                    this.protocol.getFromLocation(),
                                    0,
                                    true
                            );
                        }
                    }
                }
            }
        });
    }

    void onBreak() {
        this.spoofIncreaseLimit = System.currentTimeMillis() + 1_000L;
    }

    private void updateInternal(long time) {
        this.lastEvent = time;
    }

    void update() {
        long time = System.currentTimeMillis();

        if (v1_9) {
            this.updateInternal(time);
        }
        if (this.average.size() == TPS.maximum + 1) {
            double average = 0.0, deviation = 0.0;
            int removed = 0;

            synchronized (this.average) {
                Iterator<Long> iterator = this.average.iterator();
                long previous = iterator.next();

                while (iterator.hasNext()) {
                    long current = iterator.next();

                    if (time - current >= outdatedDelayTime) {
                        iterator.remove();
                        removed++;
                    } else if (removed <= 1) {
                        long difference = current - previous;
                        average += difference;
                        deviation += difference * difference;
                        previous = current;
                    } else {
                        break;
                    }
                }
                if (removed == 0) {
                    this.average.remove(0);
                }
                this.average.add(time);
            }

            if (removed <= 1) {
                average /= this.average.size() - 1;

                if (average >= outdatedTickTime) {
                    deviation = Math.sqrt(deviation / (double) (this.average.size() - 1));
                    deviation = Math.abs(average - deviation);

                    if (deviation < 1.0) {
                        this.delayBuffer++;

                        if (this.delayBuffer >= TPS.maximum) {
                            this.delayBuffer = 0;
                            this.delayTimes++;
                            cancel(
                                    "movement-spoof(delay)"
                                            + ", average: " + average
                                            + ", deviation: " + deviation,
                                    this.protocol.getFromLocation(),
                                    0,
                                    true
                            );
                        }
                    }
                } else {
                    this.delayBuffer = 0;
                    this.delayTimes = 0;
                }
            } else {
                this.delayBuffer = 0;
                this.delayTimes = 0;
            }
        } else {
            this.delayBuffer = 0;
            this.delayTimes = 0;

            if (!this.average.isEmpty()) {
                synchronized (this.average) {
                    Iterator<Long> iterator = this.average.iterator();

                    while (iterator.hasNext()) {
                        long current = iterator.next();

                        if (time - current >= outdatedDelayTime) {
                            iterator.remove();
                        } else {
                            break;
                        }
                    }
                    this.average.add(time);
                }
            } else {
                synchronized (this.average) {
                    this.average.add(time);
                }
            }
        }
    }

}
